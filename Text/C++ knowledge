16/12/2024

C++中, 虚函数可以为private, 并且可以被子类覆盖（因为虚函数表的传递），但子类不能调用父类的private虚函数。虚函数的重载性和它声明的权限无关。
一个成员函数被定义为private属性，标志着其只能被当前类的其他成员函数(或友元函数)所访问。而virtual修饰符则强调父类的成员函数可以在子类中被重写，因为重写之时并没有与父类发生任何的调用关系，故而重写是被允许的。
编译器不检查虚函数的各类属性。被virtual修饰的成员函数，不论他们是private、protect或是public的，都会被统一的放置到虚函数表中。对父类进行派生时，子类会继承到拥有相同偏移地址的虚函数表（相同偏移地址指，各虚函数相对于VPTR指针的偏移），则子类就会被允许对这些虚函数进行重载。且重载时可以给重载函数定义新的属性，例如public，其只标志着该重载函数在该子类中的访问属性为public，和父类的private属性没有任何关系！
纯虚函数可以设计成私有的，不过这样不允许在本类之外的非友元函数中直接调用它，子类中只有覆盖这种纯虚函数的义务，却没有调用它的权利。


数据封装和数据抽象概念的区别

关注点不同：
封装关注的是数据和操作方法的绑定，以及对外部访问的控制。
抽象关注的是简化复杂性，通过隐藏实现细节来只暴露对象的主要特性和功能。

实现方式：
封装通过访问控制（如 private、protected 和 public 访问修饰符）实现。
抽象通过抽象类和接口（纯虚函数等）实现。

目的：
封装主要是为了数据保护和隐藏实现细节。
抽象主要是为了简化复杂性和提高代码的可读性与可维护性。

侧重点：
封装侧重于对象内部的设计，通过隐藏数据和提供访问方法来保护对象的内部状态。
抽象侧重于对象对外的接口设计，通过提供简化的接口来隐藏复杂的实现细节。
