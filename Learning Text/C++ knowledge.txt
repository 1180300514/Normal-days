gcc与g++都是GNU(组织)的一个编译器。需要注意以下几点：

（1）gcc与g++都可以编译c代码与c++代码。但是：后缀为.c的，gcc把它当做C程序，而g++当做是C++程序；后缀为.cpp的，两者都会认为是C++程序。

（2）编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接。

（3）编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接（当然可以选择手动链接，使用命令如下），所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。

ex:gcc test.cpp -lstdc++ == g++ test.cpp(-l是连接某个库，-lstdc++: 是告诉编译器链接标准 C++ 库（libstdc++）的选项。这样做是因为 C++ 程序通常需要连接标准库以提供标准的类和函数实现)

Exp1 ? Exp2 : Exp3;

哈希表为什么查找的时间复杂度是O1，他在内存中是怎么储存达到这种效果的

哈希表的基本原理
哈希函数:

哈希表使用哈希函数将输入的键（key）转换为数组的索引。哈希函数可以是一个数学公式或算法，它对输入值进行计算以生成一个固定范围内的整数。
例如，如果我们有一个字符串键 "apple"，哈希函数可能返回某个整数，如 5，这意味着 "apple" 将存储在数组的第 5 个位置。
数组存储:

哈希表内部使用一个数组来存储数据。键对应的值（value）被存储在该数组的特定索引位置。这种直接映射使得查找操作非常高效。
由于我们能够通过哈希函数直接获得索引，所以查找操作的期望时间复杂度为 (O(1))。
内存中的存储方式
桶（Buckets）:

哈希表通常使用“桶”来处理冲突（即不同的键经过哈希函数后得到相同的索引）。每个桶可以是一个链表、动态数组或其他数据结构。
当多个键哈希到同一位置时，它们将被存储在同一个桶中。查找时，首先通过哈希函数找到桶，然后在桶中查找具体的键。
加载因子（Load Factor）:

加载因子是指哈希表中元素数量与桶的数量之比。为了保持查找效率，哈希表通常会在达到一定的加载因子时进行扩容，即创建一个新的、更大的数组，并重新计算每个键的哈希值以分配到新的位置。
查找过程
查找哈希表中元素的过程如下：

计算哈希值: 使用哈希函数对给定的键进行计算，从而得到索引。
访问桶: 根据计算出的索引访问数组中的相应桶。
查找元素: 在桶内（如果存在多个元素）查找所需的键。这一步可能需要遍历桶中的元素，因此在最坏情况下，查找时间复杂度为 (O(n/k))，其中 (k) 是桶的数量。
总结
哈希表的平均查找时间复杂度为 (O(1))，因为通过哈希函数可以直接定位到数组索引。
为了处理冲突，哈希表通常使用桶结构，桶内可以是链表或其他数据结构。
适当的哈希函数设计和合理的加载因子管理对于维持高效性能至关重要。
注意事项
在极端情况下（如所有键都哈希到同一位置），性能可能降到 (O(n))，但通过良好的哈希函数和适当的扩容策略，可以将这种情况降低到很小的概率。

06/12/2024
问题出现在 input_name 和 input_sex 方法的输入方式上，特别是使用了 std::cin.getline() 之后的 std::cin 输入。具体来说，当你使用 std::cin >> 来读取整数（例如学生 ID）时，std::cin 会留下换行符（\n）在输入缓冲区中。这会导致接下来的 std::cin.getline() 调用立即读取这个换行符，从而跳过输入提示。
为了修复这个问题，你可以在每次使用 std::cin >> 读取数据后添加一个 std::cin.ignore() 调用。这样可以清除输入缓冲区中的换行符，使得下一次调用 getline() 可以正常工作。
std::cin.getline() 在读取输入时，会将换行符 ('\n') 从输入流中提取出来，并且不会留下任何换行符在输入缓冲区中。因此，当你调用 std::cin.getline() 之后，输入缓冲区中的换行符会被清除。

07/12/2024
实际操作中，我们一般会在私有区域定义数据，在公有区域定义相关的函数，以便在类的外部也可以调用这些函数
有public, protected, private三种继承方式，它们相应地改变了基类成员的访问属性。
1.public 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：public, protected, private
2.protected 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：protected, protected, private
3.private 继承：基类 public 成员，protected 成员，private 成员的访问属性在派生类中分别变成：private, private, private
但无论哪种继承方式，下面两点都没有改变：
1.private 成员只能被本类成员（类内）和友元访问，不能被派生类访问；
2.protected 成员可以被派生类访问。

如果继承时不显示声明是 private，protected，public 继承，则默认是 private 继承，在 struct 中默认 public 继承。
总结一下三种继承方式：

继承方式	         基类的public成员	    基类的protected成员	  基类的private成员	      继承引起的访问控制关系变化概括

public继承	     仍为public成员      	仍为protected成员	        不可见	             基类的非私有成员在子类的访问属性不变
protected继承	   变为protected成员	    变为protected成员	        不可见	             基类的非私有成员都为子类的保护成员
private继承	     变为private成员	      变为private成员	          不可见	             基类中的非私有成员都称为子类的私有成员

11/12/2024
(x > y) ? x : y;
解释：
条件：(x > y)
这会检查 x 是否大于 y
真值情况：x
如果条件为真（即 x 大于 y），则返回 x
假值情况：y
如果条件为假（即 y 大于或等于 x），则返回 y

内联函数inline：引入内联函数的目的是为了解决程序中函数调用的效率问题，这么说吧，程序在编译器编译的时候，编译器将程序中出现的内联函数的调用表达式用内联函数的函数体进行替换，而对于其他的函数，都是在运行时候才被替代。这其实就是个空间代价换时间的i节省。所以内联函数一般都是1-5行的小函数。在使用内联函数时要留神：

1.在内联函数内不允许使用循环语句和开关语句；
2.内联函数的定义必须出现在内联函数第一次调用之前；
3.类结构中所在的类说明内部定义的函数是内联函数。

12/12/2024

1、运算重载符不可以改变语法结构。
2、运算重载符不可以改变操作数的个数。
3、运算重载符不可以改变优先级。
4、运算重载符不可以改变结合性。

1、纯虚函数声明如下： virtual void funtion1()=0; 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
2、虚函数声明如下：virtual ReturnType FunctionName(Parameter) 虚函数必须实现，如果不实现，编译器将报错，错误提示为：
error LNK****: unresolved external symbol "public: virtual void __thiscall ClassName::virtualFunctionName(void)"
3、对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
4、实现了纯虚函数的子类，该纯虚函数在子类中就变成了虚函数，子类的子类即孙子类可以覆盖该虚函数，由多态方式调用的时候动态绑定。
5、虚函数是C++中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
6、在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
7、友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
8、析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数。

虚函数可以不实现（定义）。不实现（定义）的虚函数是纯虚函数。
在一个类中如果存在未定义的虚函数，那么不能直接使用该类的实例，可以理解因为未定义 virtual 函数，其类是抽象的，无法实例化。将报错误：
undefined reference to `vtable for xxx'
这和其它语言的抽象类，抽象方法是类似的——我们必须实现抽象类，否则无法实例化。（virtual 和 abstract还是有些区别的）
也就是说，如果存在以下代码：
using namespace std;

class Base {
public:
    virtual void tall();
};

class People : Base {
public:
    void tall() {
        cout << "people" << endl;
    };
};
那么，在 main 方法中，我们不能使用 Base base; 这行代码，此时的 tall 没有实现，函数表（vtable）的引用是未定义的，故而无法执行。但我们可以使用 People people; 然后 people.tall(); 或 (&people)->tall(); 因为People实现或者说重写、覆盖了 Base 的纯虚方法 tall()，使其在 People 类中有了定义，函数表挂上去了，于是可以诞生实例了。
int main() {
//    Base base;//不可用

    People people;//可用
    people.tall();
    (&people)->tall();

    return 0;
}
上述的是针对虚函数而言，普通的函数，即使我们只声明，不定义，也不会产生上述不可用的问题。父类的虚函数或纯虚函数在子类中依然是虚函数。有时我们并不希望父类的某个函数在子类中被重写，在 C++11 及以后可以用关键字 final 来避免该函数再次被重写。

13/12/2024

virtual 关键字
虚析构函数：如果一个基类将析构函数声明为虚拟的（使用 virtual 关键字），这确保了当通过基类指针删除派生类对象时，派生类的析构函数会被正确调用。这样可以防止资源泄漏和未定义行为。

class Animal {
public:
    virtual ~Animal(); // 虚析构函数
};
如果没有将析构函数声明为虚拟的，且你通过基类指针删除派生类对象，则只会调用基类的析构函数，而不会调用派生类的析构函数，这可能会导致资源泄漏或未释放的内存。

16/12/2024

设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。如果试图实例化一个抽象类的对象，会导致编译错误。
因此，如果一个 ABC 的子类需要被实例化，则必须实现每个纯虚函数，这也意味着 C++ 支持使用 ABC 声明接口。如果没有在派生类中重写纯虚函数，就尝试实例化该类的对象，会导致编译错误。
可用于实例化对象的类被称为具体类

定义一个函数为虚函数，不代表函数为不被实现的函数。
定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
定义一个函数为纯虚函数，才代表函数没有被实现。
定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。
